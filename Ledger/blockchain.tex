\section{Blockchain}

\index{Bitcoin}
\index{blockchain} 
Blockchain refers to a specific datastructure and a distributed consensus algorithm over the datastructure for implementating a 
distributed layer system. It has been proposed and widely popularized with Bitcoin cryptocurrency application~\citep{Nakamoto:2008}. 
% It's application has since been extended to other crytocurrency applications, as well as various other domains such as 
% e-governance~\citep{Batubara:2018}, industry~\citep{Bodkhe:2020} and healthcare~\citep{Mettler:2016}. 
%
As the name suggests, the datastructure consists of a number of blocks, chained through a singly linked list. A block is a collection 
of several transactions in the system. The linked list establishes the temporal order of the blocks, and hence the contained transactions. 
The blocks can be traversed from the most recent one to the oldest one. 

\begin{definition} [blockchain]
	A {\em blockchain} is a digital and public ledger, where transactions are stored in blocks linked to each other with a
	singly linked list. A block in a blockchain has a link pointing to it's predecessor. New blocks can be appended to the 
	head of a blockchain. Existing blocks cannot be modified or deleted.
\end{definition}

The structure of a blockchain as shown in figure~\ref{fig:ledger:ledger}. Time flows from left to right in the 
diagram, i.e. the leftmost block is the oldest and the rightmost one is the most recent. Each transaction in a block contains the 
details of a transaction and a digital sinature of it's initiator. For example, when an agent $A$ transfer some asset (money) $X$ 
to an agent $B$, $A$ creates a transaction, $A \xrightarrow{X} B$, digitally signed by agent $A$. The signature serves as an 
irrepudiable proof of $A$'s endorsement for the transaction.
%
In principle, it could be possible to link the individual transactions to maintain a ledger. However, there would be a large overhead
in maintaining the links. The records are grouped in blocks in a blockchain for the sake of efficiency. Further, the records in a 
block are organized in a tree-structure, called the {\em Merkle tree}~\citep{Merkle:1989} for faster access.

\begin{figure}[!htbp]
	\centerline{
		\epsfig{figure="./Ledger/blockchain.eps", width=\linewidth}
	}
	\caption{Structure of a blockchain}
	\label{fig:ledger:ledger}
\end{figure}

\index{hash pointer|textbf}
\begin{definition}[hash pointer]
	A hash pointer is a datastructure, comprising three elements:
	\begin{enumerate}
		\item A pointer to a datastructure,
		\item The hash-value of the block, and
		\item The nonce that has been used to create the block 
	\end{enumerate}
\end{definition}

The blocks in a blockchain are linked with hash pointers. The purpose of maintaining the hash-value is to make the ledger 
tamper-evident. If a block is tampered with by a dishonest agent, it's hash value changes, necessitating an update of the hash 
pointer in the next block that points to it. In consequence, the hash value of that block also changes requiring 
an update in the subsequent block. This becomes a recursive process till the head (most recent block) of the chain. Thus, the 
head of the corrupt ledger becomes inconsistent with the honest versions of the ledger, and the tampering can be easily detected. 
Further, as we shall see later, changing the hash values in several blocks in the chain requires huge computing efforts, making 
it tamper-resistant.

\index{genesis block|textbf}
\begin{definition} [genesis block]
	The {\em genesis block} is the first block ever created in a block chain and contains a null hash pointer. 
\end{definition}

\subsection{Distributed Consensus in Blockchain}
\label{sec:ledger:nakamoto-consensus}

\index{distributed consensus!in blockchain} \index{Nakamoto consensus protocol}
The Nakamoto consensus protocol proposed for the Bitcoin system can be used in large permissionless networks. The protocol can 
best be described as an inductive algorithm. Assuming that consensus exists till a certain block in a block chain, we shall show
that consensus will be reached for the next block too. 

\index{transaction pool!in blockchain}
Transaction records are generated by the participating agents at random intervals at the different nodes. An agent, when it generates 
a record, percolates it in the network. Thus, at any given point of time, every agent in the network has a reference version of the 
blockchain (on which consensus have been previously reached) and a pool of unprocessed transactions. There can be differences in the 
pool of unprocessed transactions across the agents, because of various reasons, such as network/node faults or malicious behavior of 
some agents (dropping an honest record, or adding a dishonest one). 
%
Once sufficient number of records are available with an agent, it creates a block, and appends the block to the blockchain after 
computing the hash of the previous block. The information of the new block is percolated in the network. The recipient agents validate
the block (which we shall explain shortly) before accepting it.

% \subsection{Consensus Protocol in Blockchain}
\index{puzzle friendly}
Since the agents work independently, it is possible for them to append different versions of a new block in parallel to an existing 
blockchain, thereby creating inconsistency in the system. In order to avoid the inconsistency, only one agent is allowed to append 
a block to the blockchain at a time. In a peer-to-peer system, there is no central coordinator to grant the permission, and the agents 
need to coordinate amongst themselves for the purpose. This coordination is achieved by creating a ``puzzle'', which an egent need
to solve to qualify for appending a block. 
 
\index{proof of work|see {PoW}}
\index{PoW|textbf}
Recall that an agent needs to compute the hash of the previous block to create the hash pointer for the current block. The legal 
hash values in a blockchain is restricted to a narrow range of the hash space. Thus, an agent needs to discover a suitable nonce 
that generates the hash for the previous block in the given range, and it has no better method than trial and error to find it. 
Note that we are using the puzzle-friendly property of a hash function.

\begin{definition} [proof of work]
	A {\em proof of work} (PoW) is a piece of data which requires a large yet feasible amount of computing resources to produce, 
	but requires very less computing resources for others to verify. Producing a proof of work is generally a random process 
	with low probability of success, so that, on the average, many trials are required before a valid proof of work is generated. 
\end{definition}

An agent that solves the puzzle and produces the {\em proof of work} first, either by chance or by possessing more computing power, 
qualifies to append a block to the blockchain, and percolates the block in the network. The other agents accepts the block after
verifying the proof of work (which is not an expensive operation). All the agents append the block to their version of the blockchain, 
and remove the records included in the block from their respective unprocessed transactions pool. The process repeats indefinitely
in the network.

\index{Bitcoin}
The PoW required to append a block deliberately slows down the process of creation of new blocks, so that there is ample time
for a block to propagate to all agents in an open network and be appended to their respective versions of the blockchain. 
For example, the range of the valid hash values in the Bitcoin network had been initially restricted to $1/10^{20}$-th of the 
hash space, which implies that an agent, on the average, will have to make $50 \times 10^{18}$ trials to find a solution to the 
puzzle. The average {\em block-time} (time to produce a new block) is mainatined at about 10 minutes by dynamically adjusting
the the window for the valid hash values. Thus, the blockchain in the Bitcoin network can handle about 4--5 transactions per 
second. 
%
Further, PoW makes a blockchain tamper-resistant. If an existing block in the blockchain is to be tampered with, the hash pointers 
of all the blocks from the tampered block to the most recent block in the chain need to be updated, which becomes a formidable task 
if the blockchain has sufficiently grown after the block to be tampered. 
%
\index{mining reward} \index{block reward} \index{block mining}
The PoW required to contribute a block, which is the key element for distributed consensus in blockchain, requires spending significant 
computing efforts, and Bitcoin application provides a financial reward to the agent who contributes a block. Creation of a block is 
called {\em block mining} and the reward provided is known as the {\em block reward} or {\em mining reward}. Though this mechanism works 
well for Bitcoin and other crypto-currency applications, it is difficult to provide such motivation in other applications. 
%
Note that the consensus protocol achieves consistency in the blockchain, but cannot prevent erroneous or dishonest records from
being included in the blocks. We shall explain the methods to prevent it later in the text. 

\subsection{Forking}
\label{sec:ledger:forking}

Though a consensus about the contents of a distributed ledger can generally be achieved with the algorithm described in the previous
section, it is still possible for different nodes to have different versions of the chain in any of the following conditions:

\index{double spend attack}
\begin{itemize}
	\item Two agents accidentally solves the hash pointer puzzle almost at the same time, and broadcast their respective
		versions. 
	\item The information about a new block does not reach an agent in time. The agent appends a different new block to an 
		earlier version of the blockchain. 
	\item An dishonest agent deliberately creates a block with dishonest transaction and appends it to an earlier version
		of the blockchain in an attempt to ``erase'' an earlier honest transaction. This is known as the {\em double spend
		attack}, where an agent attempts to spend the same coin twice, once in the honest transaction and then in the
		dishonest transaction.
\end{itemize}

\index{forking}
\index{mechanism design!in blockchain}
In any of the case, some of the agents will accept one version of the blockchain, and some will accept the other. This is known as 
{\em forking}, and is depicted in figure~\ref{fig:ledger:fork}. In the figure, there is a global consensus for  blocks 0--2 
(preceding the fork), but not for the subsequent blocks. While there is no technology solution for this problem, a mechanism has been 
designed to recover from the situation. As per blockchain protocol, the longest blockchain (that accumulates maximal PoW) is to be 
accepted by an agent. Due to statistical variations, when one branch of the fork becomes longer that the other, more and more agents 
tend to adopt the former, and eventually, all agents converge to the same version of the blockchain. If both the branches contains 
honest transactions only, eventually all the transactions get accounted for in the blockchain. If one of the branches contain a 
dishonest record (double spend attack), it is possible (though with very little probability), that the branch with the dishonest 
transaction gets eventually accepted. The risk is mitigated by application-specific mechanisms. 

\begin{figure}[!htbp]
	\centerline{
		\epsfig{figure="./Ledger/fork.eps", width=0.9\linewidth}
	}
	\caption{Forking in a blockchain}
	\label{fig:ledger:fork}
\end{figure}

\index{soft fork} \index{hard fork} \index{Bitcoin} \index{Bitcoin Cash}
Forking in a blockchain can also result from a change in the protocol, e.g. a change in some parameters, say the maximum block-size. 
Any such change requires time to propagate down the nodes in the network. During the interim period, some agents will follow the old 
policies and some will follow the new ones, resulting in two versions of the blockchain. When the changes are backward compatible, 
meaning that all operations that are valid under new policies are valid under the old ones, the two prongs of the fork eventually 
converge when the majority of the nodes adopt the new policy. This situation is called a {\em soft fork}. On the 
contrary, when the changes are not backward compatible, i.e. some operations valid under new policies are invalid under the 
old ones, the prongs never merge, and two separate chains (with mutually exclusive set of subscribers) continue for ever. 
This is known as the {\em hard fork}. In effect, they two chains become two separate applications. An example of a hard fork 
was fragmentation of Bitcoin in two separate crypto-currencies, the original Bitcoin (BTC) and Bitcoin Cash (BCH), in 2017.
An interesting observation for hard fork is that the original assets (before the fork) are duplicated, since they are valid 
in both the forks.

\subsection{Asset Tracking}
\label{sec:ledger:tracking}

In general, a ledger deals with some assets (including money). Blockchain enables asset tracking by maintaining links across the 
records dealing with an asset. For example, if an agent $A$, which owns an asset $X$, transfer it to agent $B$ (record $i$), and 
subsequently, $B$  transfers it to $C$ (record $j$), and then $C$ to $D$ (record $k$), then records $i, j$ and $k$ are linked as 
shown in figure~\ref{fig:ledger:records}. Thus, the ownership of an asset can be traced from it's current owner to it's 
genesis when it is created or deployed in the system. An asset may be created at any given time, and not necessarily in 
the genesis block of the blockchain. 

\index{collision resistance}
Every record in a blockchain is uniquely identified in a system by it's double hash (recall collision resistance property of hash
function), and the links connecting the records are maintained as hash pointers. Note that these hash pointers are distinct from 
those linking the blocks in a blockchain. Records $i,j$ and $k$ may exist in any of the blocks, the only restriction being 
$block(i) \prec block(j) \prec block(k)$, where $block(x): x \in \{i,j,k\}$ represents the block that contains the record $x$, and 
$\prec$ represents precedence relation in the blockchain. 

\begin{figure}[!htbp]
	\centerline{
		\epsfig{figure="./Ledger/records.eps", width=0.6\linewidth}
	}
	\caption{Asset tracking in blockchain}
	\label{fig:ledger:records}
\end{figure}

A transaction record carrying a valid hash pointer is not a proof of the fact that the initiator is the current owner of the
asset. While the asset belonged to the agent at some point of time in the past (where the hash pointer points to), but may have 
been transferred to some other agent in the meantime. For example, it may be possible that the agent $C$ may try to transfer the 
asset $X$ to another agent $E$ (either by mistake or maliciously) after it has already been transferred to agent $D$ (record $l$
in the figure). Thus, validation of a transaction needs to constitute following steps:

\begin{enumerate}
	\item {\em The identity of the initiator}, validated with the signature in the transaction record.
	\item {\em The validity of the asset}, by checking the hash pointer pointing to the linked record.
	\item {\em That the initiator is the current owner of the asset}, validated by scanning all the blocks, from
		the most recent one to the linked record (where the current initiator had been declared to 
		be the owner of the asset), to check if the asset has been transferred in the intervening period.
\end{enumerate}

For divisible assets, such as money, the chaining of the records becomes a little more complex. The older assets are ``consumed''
(destroyed) and new assets are created. For example, if an agent $A$ has 12 BTC and it wants to pay 10 BTC to an agent $B$ and 
keep the change of 2 BTC, the record shows an input coin of denomination 12 BTC from $A$ being consumed and two new coins of 
denominations 10 BTC and 2 BTC being generated and being allocated to agents $B$ and $C$ respectively. Such a transaction is 
shown in figure~\ref{fig:ledger:state-machine}.

